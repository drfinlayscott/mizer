---
title: "Model Description"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{Mizer Developer Vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

In this document we will revisit the presentation of the mizer model given
in chapter 3 of the main [mizer vignette](https://cran.r-project.org/web/packages/mizer/vignettes/mizer_vignette.pdf)
but taking care to separate the essential features of the model that are
hard-coded and the various possible specialisations for which mizer 
provides setup functions. We will not go into detail of how this model is 
realised in code. Such detail will be provided in the [developer_vignette].

# The mizer size-spectrum model

## Fish size spectrum
The model framework builds on two central assumption and a number of lesser 
standard assumption.  

The first central assumption is that an individual can be characterized by its 
weight $w$ and its species number $i$ only. The aim of the model is to calculate 
the size spectrum $N_i(w)$, which is the *density* of individuals of
species $i$ such that $\int_w^{w+dw}N_i(w)dw$ is the *number* of individuals of
species $i$ in the size interval $[w,w+dw]$. 

To represent this continuous size spectrum in the computer, the size
variable $w$ is discretized into a vector 'w' of discrete weights,
providing a grid of sizes spanning the range from the smallest egg size
to the largest asymptotic size. These grid values divide the full size
range into a finite number of size bins. The size bins should be chosen
small enough to avoid the discretisation errors from becoming too big.

In the code the size spectrum is stored as an array such that `n[i, a]`
holds the density $N_i(w_a)$ at weights $w_a=$`w[a]`, or, if time
dependence is included, an array such that `n[i, a, u]`
holds $N_i(w_a,t_u)$.

Note that, contrary to what one might have expected,
`n[i, a]` is not the *number* of individuals in a size bin
but the *density* at a gid point.
The number of individuals in the size bin between `w[a]` and
`w[a+1]=w[a]+dw[a]` is only approximately given as `n[i, a]*dw[a]`,
where `dw[a]= w[a+1]-w[a]`.

The time evolution of the size spectrum is described by the 
McKendrik-von Foerster equation, which is simply a transport equation:

\begin{equation}
  \label{eq:MvF}
  \frac{\partial N_i(w)}{\partial t} + \frac{\partial g_i(w) N_i(w)}{\partial w} 
  = -\mu_i(w) N_i(w),
\end{equation}

where individual growth $g_i(w)$ and mortality $\mu_i(w)$ will be described
below. This is supplemented by a reproduction equation that describes the
production of eggs, to be described below.

This McKendrik-von Foerster equation is approximated in mizer by a
finite-difference method (to be described in section ...). This allows the
`project()` method in mizer to project the size
spectrum forwards in time: Given the spectrum at one time the `project()` method
calculates it at a set of later times.

## Resource size spectrum

Besides the fish spectrum there is also a resource spectrum $N_R(w)$,
representing for example the phytoplankton. This extends over a wider size range
than the fish spectrum and it is discretized into a vector of weights
`w_full`. The last entries of `w_full` have to coincide with the entries
of `w`. The resource spectrum is then stored in a vector `n_pp` such that
`n_pp[c]` =$N_R($`w_full[c]`$)$.

The time evolution of the resource spectrum is described by a 
semi-chemostat equation:
\begin{equation}
  \label{eq:nb}
  \frac{\partial N_R(w,t)}{\partial t} 
  = r_p(w) \Big[ c_p (w) - N_R(w,t) \Big] - \mu_p(w) N_R(w,t).
\end{equation}
Here $r_p(w)$ is the population regeneration rate, stored as a vector
`params@rr_pp[c]`$=r_p($`w_full[c]`$)$, and $c_p(w)$ is the carrying capacity
in the absence of predation, stored as a vector
`params@cc_pp[c]`$=c_p($`w_full[c]`$)$. The death $\mu_p(w)$ is described 
in the subsection [Plankton mortality].


## Encounter rates
We first discuss the rates at which fish could predate if they were not
subject to satiation. We refer to these as encounter rates. We will 
discuss in the next subsection that satiation leads to only a certain 
proportion of the encountered prey actually being consumed.

Let $\gamma_{ij}(w,w_p)$ be the per capita predation rate at which a given 
individual of species $i$ and weight $w$ encounters a given individual of 
species $j$ and weight $w_p$. 
Similarly let $\gamma_{iR}(w,w_p)$ be the per capita encounter rate at which a
given  individual of species $i$ and weight $w$ encounters on a given plankton
individual of weight $w_p$. Then the total rate at which prey biomass
is encountered by a predator of species $i$ and weight $w$  is obtained by 
integrating and summing over all possible prey, weighted by their biomass:
\[\begin{split}
E_{e.i}(w) = &\sum_j\int \gamma_{ij}(w,w_p)\, N_j(w_p)\,w_p\,dw_p\\
&+\int \gamma_{iR}(w,w_p)\, N_R(w_p)\,w_p\,dw_p.
\end{split}\]

The per capita encounter rate $\phi_{ij}(w, w_p)$ is assumed to factorize as 
\[\gamma_{ij}(w, w_p)=\theta_{ij}\,\gamma_i(w,w_p)\] 
into a species preference matrix $\theta_{ij}$ and an encounter rate
$\gamma_i(w, w_p)$ that is independent of the prey species.


## Consumption rates
The encountered food is consumed subjected to a standard Holling functional 
response type II to represent satiation. This determines the 
*feeding level* $f_i(w)$, which is a dimensionless number between 0 
(no food) and 1 (fully satiated) so that $1-f_i(w)$ is the proportion of the
encountered food that is consumed. The feeding level is given by

\begin{equation}
  \label{eq:f}
  f_i(w) = \frac{E_{e.i}(w)}{E_{e.i}(w) + h_i(w)},
\end{equation}

where $h_i(w)$ is the maximum consumption rate stored in
`params@intake_max[i,a]`. 

The feeding level is calculated with the function `getFeedingLevel()`.

The rate at which food is consumed is then 
\[E_{c.i}(w)=(1-f_i(w))E_{e.i}(w)=f_i(w)\, h_i(w).\]

## Metabolic losses

Only a fraction $\alpha$ of the consumed food can be converted into predator
biomass, and even of that some is first needed for metabolism and 
activity and movement, and only what remains can be used for reproduction 
and growth. 
The rate $\text{metab}_i(w)$ at which biomass is lost to metabolism, activity 
and movement is stored in the array `metab[i,a]`.

So the rate at which biomass becomes available for growth and reproduction is
\begin{equation}
  \label{eq:Er}
  E_{r.i}(w) = \max(0, \alpha f_i(w)\, h_i(w) - \text{metab}_i(w))
\end{equation}
This is calculated with the `getEReproAndGrowth()` function.


## Investment into reproduction
A proportion $\psi_i(w)$ of the energy available for growth and reproduction
is used for reproduction. This proportion should change from zero below the  
weight $w_{m.i}$ of maturation to one at the asymptotic weight 
$W_i$, where all available energy is used for reproduction. This proportion
is stored in an array `psi[i,a]`$=\psi_i(w_a)$.

The total production rate of egg production $R_{p.i}$ (numbers per time) is found by 
integrating the contribution from all individuals of species $i$:
\begin{equation}
  \label{eq:Rp}
  R_{p.i} = \frac{\epsilon}{2 w_0} \int N_i(w)  E_{r.i}(w) \psi_i(w) \, dw,
\end{equation}
where the individual contribution is obtained by multiplying the rate at which the
individual allocates energy to reproduction by an efficiency factor $\epsilon$ 
and then dividing by the egg weight $w_0$ to convert the energy into number of eggs.
The result is multiplied by a factor $1/2$ to take into account that only 
females reproduce.


## Growth
What is left over after metabolism and reproduction is taken into account
is invested in somatic growth. Thus the growth rate is
\begin{equation}
  \label{eq:growth}
  g_i(w) = E_{r.i}(w)\left(1-\psi_i(w)\right).
\end{equation}
It is calculated by the `getEGrowth()` function.

When food supply does not cover the requirements of metabolism and activity, 
growth and reproduction stops, i.e. there is no negative growth.
The individual should then be subjected to a starvation mortality, but starvation
mortality is not implemented in mizer at the moment.


## Recruitment


## Mortality
The mortality rate of an individual $\mu_i(w)$ has three sources: 
predation mortality $\mu_{p.i}(w)$, background mortality $\mu_{b.i}(w)$ and 
fishing mortality $\mu_{f.i}(w)$. 

Predation mortality is calculated such that all that is eaten translates into 
corresponding predation mortalities on the ingested prey individuals. 
Recalling that $1-f_i(w)$ is the proportion of the food encountered by a 
predator of species $i$ and weight $w$ that is actually consumed, the
rate at which an individual of species $j$ and weight $w_p$ is predated is
\begin{equation}\label{eq:pred_mort}
  \mu_{p.j}(w_p) = \sum_i \int \gamma_{ij}(w,w_p) (1-f_i(w))\, N_i(w) \, dw.
\end{equation}
This predation mortality rate is calculated by the function `getPredMort()`.

Background mortality $\mu_{b .i}(w)$ is stored in the array `params@mu_b[i,a]`.

Fishing mortality $\mu_{f.i}(w)$ will be discussed in section [Fishing].

The total mortality rate
\[\mu_i(w)=\mu_{p.i}(w)+\mu_{b.i}(w)+\mu_{p.i}(w)\]
is calculated with the function `getMort()`.

## Plankton Mortality

The predation mortality rate on plankton is given by a similar expression
as the predation mortality on fish:
\begin{equation}
  \label{eq:mupp}
  \mu_{p}(w_p) =  \sum_i \int \gamma_{iR}(w,w_p) (1-f_i(w))\, N_i(w) \, dw.
\end{equation}
This is the only mortality on plankton currently implemented in mizer.
It is calculated with the function `getPlanktonMort()`.


# Optional further model assumptions

## Logarithmically-sized size bins
In general the weight grid used by mizer is arbitrary and is
stored in the vector `params@w` for the fish part of the spectrum and in
`params@w_full` for the entire spectrum. The only restriction is that the
weights in these vectors are strictly increasing and that the last
entries of `params@w_full` coincide with the entries of `params@w`.

However by default the weight grid is set up to be logarithmically spaced,
so that
`w[j]=w[1]*exp(j*dx)` for some fixed `dx`. 
This grid is set up when creating a MizerParams object, see
`emptyParams()` for details.


## Fixed predator/prey mass ratio
An important simplification occurs when the preference $\phi_i(w,w_p)$
of a predator of size $w$ for prey of size $w_p$ depends on the size 
of the prey **only** through the predator/prey size ratio $w_p/w$,
\[\phi_i(w, w_p)=\tilde{\phi}_i(w/w_p).\]

The choice of the function is not central. It is currently
hard-coded to the truncated log-normal function
\[
  \label{eq:4}
  \tilde{\phi}_i(x) = \begin{cases}
  \exp \left[ \dfrac{-(\ln(x / \beta_i))^2}{2\sigma_i^2} \right]
  &\text{ if }x\in\left[0,\beta_i\exp(3\sigma_i)\right]\\
  0&\text{ otherwise,}
  \end{cases}
\]
where $\beta_i$ is the preferred predator-prey mass ratio and $\sigma_i$ the 
width of the weight selection function.

## Allometric rates
Mizer has several size-dependent rates for which it is sensible to assume
an allometric scaling with size:

* Resource carrying capacity
\[c_p(w)=\kappa\, w^{-\lambda}.\]

* Resource growth rate
\[r_p(w)= r_p\, w^{n-1}.\]

* Search volume
\[\gamma_i(w) = \gamma_i\, w^q.\]

* Maximum intake rate
\[h_i(w) = h_i\, w^n.\]

* Metabolic loss
This is made up out of standard metabolism, scaling with exponent $p$, and
loss due to activity and movement, scaling with exponent $1$:
\[\text{metab}_i(w) = k_{s.i}\,w^p + k_i\,w.\]

* Background mortality
\[\mu_{b.i}(w) = \mu_b W_i^{1-n},\]
where $W_i$ is the asymptotic size of species $i$.


## Investment into reproduction
The proportion $\psi_i(w)$ that determines how much of the available energy
is used for reproduction should be described by a function that starts rising
from $0$ at around the maturity size $w_{\text{mat}.i}$ of the species $i$ and reaches $1$ at
the asymptotic size $w_{\infty.i}$ of the species.

Mizer provides a default function
\[\psi_i(w)=\begin{cases}
  0 & w < \frac{w_{\text{mat}.i}}{10}\\
  \left(1+\left(\frac{w}{w_{\text{mat}.i}}\right)^{10}\right)^{-1}
  \left(\frac{w}{w_{\infty.i}}\right)^{1-n} & 
  \frac{w_{\text{mat}.i}}{10} \leq w \leq w_{\infty.i}\\
  1 & w>w_{\infty.i}.
\end{cases}
\]


# Fishing
This section still to be written.



[Edit this page](https://github.com/gustavdelius/mizer/edit/master/vignettes/model_description.Rmd)
