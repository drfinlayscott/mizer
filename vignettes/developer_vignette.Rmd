---
title: "Mizer Developer Vignette"
author: "Gustav Delius and Richard Southwell"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{Mizer Developer Vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction

This vignette is for you if you need to extend mizer 
to meet the needs of your research project.
You will already have read the [main mizer vignette](https://cran.r-project.org/web/packages/mizer/vignettes/mizer_vignette.pdf) and thus be
familiar with what mizer can do out of the box.
You now want to implement the extension or modification of the
model required for your research, and for that you need to dive into 
the internal workings of mizer. This vignette is meant to make
that as easy as possible.

The first thing you should do, even before reading this vignette, is to
go to https://github.com/sizespectrum/mizer/issues and create a new "issue""
to share your ideas and plans with the mizer community. You may get back 
valuable feedback and advice. Another way to get in touch with the
mizer community is via the [size-spectrum modelling Google group](https://groups.google.com/forum/#!forum/size-spectrum-models).

# Preparation
In this section we describe how to set up your working environment
to allow you to easily work with the mizer code. Much of it you
may already have in place, so feel free to skip ahead.

## Installing R, RStudio, devtools

Mizer is compatible with R versions 3.1 and later.
If you still need to [install R](https://cran.r-project.org/), simply install 
the latest version. This vignette was prepared with
`r R.version.string`.

This guide assumes that you will be using RStudio to work with R. There is
really no reason not to use RStudio and it makes a lot of things much easier.
RStudio develops rapidly and adds useful features all the time and so it pays 
to upgrade to the [latest version](https://www.rstudio.com/products/rstudio/download/preview/) 
frequently. This guide was written with version 1.2.1114.

To work with R packages as a developer, you will need to
[install additional tools](https://support.rstudio.com/hc/en-us/articles/200486498-Package-Development-Prerequisites). Once you have these in place, you should install the devtools package with
```{r eval=FALSE}
install.packages("devtools")
```
You are now all set to develop R packages, and 
[RStudio makes this extra easy](https://support.rstudio.com/hc/en-us/articles/200486488-Developing-Packages-with-RStudio). There is even a cheat sheet for package development accessible from the Help menu in RStudio.

## Installing git
In case git is not already installed on your system, you need to 
[install it](http://happygitwithr.com/install-git.html). You do not need to install
any GUI for git because RStudio has 
[built-in support for git](https://support.rstudio.com/hc/en-us/articles/200532077-Version-Control-with-Git-and-SVN). 
A good place to learn about using git and github is 
[this chapter](http://r-pkgs.had.co.nz/git.html) 
in the guide by Hadley on R package development.

## Forking mizer from github

Mizer is developed using the version control system _git_ and the code is hosted on github.
To work with the code you will create your own git repository with a copy of the mizer code.

Go to https://github.com/sizespectrum/mizer and fork it into your own repository. 
Then create a version control new project in Rstudio, and indicate your depository url.
On the "Git" tab select the "dev" branch. This contains the latest development
code for mizer. 

To run this code go to the "Build" tab in RStudio and click on "Install and Restart". 
This builds and loads the mizer package based on this development code.


# Implementation of the model

In this section we will revisit the presentation of the mizer model given
in chapter 3 of the main [mizer vignette](https://cran.r-project.org/web/packages/mizer/vignettes/mizer_vignette.pdf)
but taking care to separate the essential features of the model that are
hard-coded and the various possible specialisations for which mizer 
provides setup functions. We will also give some detail of how this model is 
implemented in code. We will still
stay a bit at the surface, delaying a detailed look at how the code is
organised until the section [Finding your way around the mizer code].

Mizer is organised in a modular fashion. It is separated into setup functions,
simulation functions, and analysis and plotting functions. These will
be described below after we have introduced the mizer model.

The core of mizer is the `project()` function
that runs a simulation of the size-spectrum model. It takes a specification
of the model contained in an object of type `MizerParams` and returns the
results of the simulation in an object of type `MizerSim`.

There are several different methods for setting up a `MizerParams` object for
specifying various concrete models. These setup functions make various 
simplifying assumptions about the model parameters to reduce the amount of
information that needs to be specified. This usually takes the form of
assuming allometric scaling laws. Below we will first describe the most
general size spectrum model handled by mizer before describing the
specialisations for which mizer has special setup functions.

There are many functions for analysing and plotting the results of a mizer
simulation contained in a `MizerSim` object.

The `MizerParams` and `MizerSim` objects are S4 objects,
meaning that their slots are rigorously defined and are accessed with the '@'
notation. You do not need to learn about S4 classes in order to understand the
mizer code, because the code avoids using S4 methods. In the presentation
below we assume that the `MizerParams` object is called `params` and the
`MixerSim` object is called `sim`.

## The general mizer model

### Fish size spectrum
The model framework builds on two central assumption and a number of lesser 
standard assumption.  

The first central assumption is that an individual can be characterized by its 
weight $w$ and its species number $i$ only. The aim of the model is to calculate 
the size spectrum $N_i(w)$, which is the *density* of individuals of
species $i$ such that $\int_w^{w+dw}N_i(w)dw$ is the *number* of individuals of
species $i$ in the size interval $[w,w+dw]$. 

To represent this continuous size spectrum in the computer, the size
variable $w$ is discretized into a vector of weights `w` of
length `no_w`. 

In the code the size spectrum is stored as an array such that `n[i, a]`
holds the density $N_i(w_a)$ at weights $w_a=$`w[a]`, or, if time
dependence is included, an array such that `n[i, a, u]`
holds $N_i(w_a,t_u)$.

Note that contrary to what one might have expected,
`n[i, a]` is not the *number* of individuals in a size bi
but the *density* at a gid point.
The number of individuals in the size bin between `w[a]` and
`w[a+1]=w[a]+dw[a]` is only approximately given as `n[i, a]*dw[a]`,
where `dw[a]= w[a+1]-w[a]`.

The time evolution of the size spectrum is described by the 
McKendrik-von Foerster equation, which is simply a transport equation:

\begin{equation}
  \label{eq:MvF}
  \frac{\partial N_i(w)}{\partial t} + \frac{\partial g_i(w) N_i(w)}{\partial w} 
  = -\mu_i(w) N_i(w),
\end{equation}

where individual growth $g_i(w)$ and mortality $\mu_i(w)$ will be described
below. This is supplemented by a reproduction equation that describes the
production of eggs, to be described below.

This McKendrik-von Foerster equation is approximated in mizer by a
finite-difference method (to be described in section ...). This
allows the `project()` method in mizer to project the size spectrum 
forwards in time: Given the spectrum at one time the `project()` method
calculates it at a set of later times.

### Resource size spectrum

Besides the fish spectrum there is also a resource spectrum $N_R(w)$,
representing for example the phytoplankton. This extends over a wider
size range which is discretized into a vector of weights `params@w_full` of
length `no_w_full`. The last `no_w` entries of `w_full` have to 
coincide with the entries of `w`. The resource spectrum is then stored
in a vector `n_pp` such that `n_pp[c]` =$N_R($`w_full[c]`$)$.

The time evolution of the resource spectrum is described by a 
semi-chemostat equation:
\begin{equation}
  \label{eq:nb}
  \frac{\partial N_R(w,t)}{\partial t} 
  = r_p(w) \Big[ c_p (w) - N_R(w,t) \Big] - \mu_p(w) N_R(w,t).
\end{equation}
Here $r_p(w)$ is the population regeneration rate, stored as a vector
`params@rr_pp[c]`$=r_p($`w_full[c]`$)$, and $c_p(w)$ is the carrying capacity
in the absence of predation, stored as a vector
`params@cc_pp[c]`$=c_p($`w_full[c]`$)$. The death $\mu_p(w)$ is described 
in the subsection [Plankton mortality].


### Predator-prey preference
The preference $\phi_{ij}(w, w_p)$ of
an individual of species $i$ and weight $w$ for prey of species $j$ and
weight $w_p$ is assumed to factorize as 
\[\phi_{ij}(w, w_p)=\theta_{ij}\,\phi_i(w,w_p)\] 
into a species preference matrix $\theta_{ij}$ and a weight selection function
$\phi_i(w, w_p)$. 

The species preference matrix $\theta_{ij}$, also referred to as the
species interaction matrix, is stored in `params@interaction[i,j]`.

The weight selection function is stored in an array
`params@pred_kernel[i,a,c]`$=\phi_i($`w[a]`,`w_full[c]`$)$, 
i.e., the first index specifies the predator species, the second the
predator size class (and ranges only over fish spectrum) and the third index
specifies the prey size class and ranges over the entire spectrum.



### Available energy

The available food for a predator of species $i$ and weight $w$ is determined 
by summing over all prey species and the resource spectrum and integrating
over all prey sizes $w_p$, weighted by the size selection function: 

\begin{equation}
  \label{eq:1}
  E_{a.i}(w) = \int \left( N_R(w_p) + \sum_{j} \theta_{ij} N_j(w_p) \right) 
  \phi_i(w,w_p) w_p \, dw_p.
\end{equation}

This available energy is calculated by the `getAvailEnergy()` function.
The integral is approximated by a Riemann sum over all weight brackets.
\[
\text{avail_energy}[i,a] = \sum_{k}
\left( n_{pp}[k] + \sum_{j} \theta[i,j] n[j,k] \right) 
  \phi_i\left(w[a],w[k]\right) w[k]\, dw[k].
\]


### Consumption

The food actually encountered $E_{e.i}$ (mass per time) depends on the search 
volume rate (volume per time):

\begin{equation}
  \label{eq:Ee}
  E_{e.i}(w) = \text{search_vol}_i(w) E_{a.i}(w).
\end{equation}
The search volume is stored in an array `params@search_vol[i,a]` where
the first index specifies the species and the second the weight of the
predator.

The encountered food is consumed subjected to a standard Holling functional 
response type II to represent satiation. This determines the 
*feeding level* $f_i(w)$, which is a dimensionless number between 0 
(no food) and 1 (fully satiated) so that $1-f_i(w)$ is the proportion of the
encountered food that is consumed. The feeding level is given by

\begin{equation}
  \label{eq:f}
  f_i(w) = \frac{E_{e.i}(w)}{E_{e.i}(w) + \text{intake_max}_i(w)},
\end{equation}

where $\text{intake_max}_i(w)$ is the maximum consumption rate stored in
`params@intake_max[i,a]`. The rate at which food is
consumed is then $(1-f_i(w))E_{e.i}(w)=f_i(w)\cdot \text{intake_max}_i(w)$.

The feeding level is calculated with the function `getFeedingLevel()`.


### Growth

Some of the consumed food is used to fuel the needs for metabolism and 
activity and movement, at a rate $\text{metab}_i(w)$, stored in the
array `params@metab[i,a]`.
The remaining rate, if any, is assimilated with an efficiency $\alpha$ and 
is then available for growth and reproduction. So the rate at which energy
becomes available for growth and reproduction is
\begin{equation}
  \label{eq:Er}
  E_{r.i}(w) = \max(0, \alpha f_i(w) \text{intake_max}_i(w) - \text{metab}_i(w))
\end{equation}
 This is calculated with the `getEReproAndGrowth()` function.

When food supply does not cover the requirements of metabolism and activity, 
growth and reproduction stops, i.e. there is no negative growth.
The individual should then be subjected to a starvation mortality, but starvation
mortality is not implemented in mizer at the moment.

A proportion $\psi_i(w)$ of the energy available for growth and reproduction
is used for reproduction. This proportion should change from zero below the  
weight $w_{m.i}$ of maturationto one at the asymptotic weight 
$W_i$, where all available energy is used for reproduction. This proportion
is stored in an array `params@psi[i,a]`$=\psi_i(w_a)$.

Thus the somatic growth rate is then given by
\begin{equation}
  \label{eq:growth}
  g_i(w) = E_{r.i}(w)\left(1-\psi_i(w)\right).
\end{equation}
It is calculated by the `getEGrowth()` function.


### Reproduction
The total production rate of egg production $R_{p.i}$ (numbers per time) is found by 
integrating the contribution from all individuals of species $i$:
\begin{equation}
  \label{eq:Rp}
  R_{p.i} = \frac{\epsilon}{2 w_0} \int N_i(w)  E_{r.i}(w) \psi_i(w) \, dw,
\end{equation}
where the individual contribution is obtained by multiplying the rate at which the
individual allocates energy to reproduction by an efficiency factor $\epsilon$ 
and then dividing by the egg weight $w_0$ to convert the energy into number of eggs.
The result is multiplied by a factor $1/2$ to take into account that only 
females reproduce.


### Recruitment


### Fish Mortality
The mortality rate of an individual $\mu_i(w)$ has three sources: 
predation mortality $\mu_{p.i}(w)$, background mortality $\mu_{b.i}(w)$ and 
fishing mortality $\mu_{f.i}(w)$. 

Predation mortality is calculated such that all that is eaten translates into 
corresponding predation mortalities on the ingested prey individuals. 
Recalling that $1-f_j(w)$ is the proportion of the food encountered by a 
predator of species $j$ and weight $w$ that is actually consumed, the
rate at which all predators of species $j$ consume prey of size $w_p$ is
\begin{equation}
  \label{eq:pred_rated}
  \text{pred_rate}_j(w_p) = \int \phi_j(w,w_p) (1-f_j(w))
  \text{search_vol}_j(w) N_j(w) \, dw.
\end{equation}
This predation rate is calculated by the function `getPredRate()`.
The integral is approximated by a Riemann sum over all fish weight brackets.
\[
\text{pred_rate}[j,c] = \sum_{a}
  \text{pred_kernel}[j,a,c]\,(1-\text{feeding_level}[j,a])\,
  \text{search_vol}[j,a]\,n[j,a]\,dw[a].
\]

The mortality rate due to predation is then obtained as
\begin{equation}
  \label{eq:mup}
  \mu_{p.i}(w_p) = \sum_j \text{pred_rate}_j(w_p)\, \theta_{ji}.
\end{equation}
This predation mortality rate is calculated by the function `getPredMort()`

Background mortality $\mu_{b .i}(w)$ is stored in the array `params@mu_b[i,a]`.

Fishing mortality $\mu_{f.i}(w)$ will be discussed later.

The total mortality rate
\[\mu_i(w)=\mu_{p.i}(w)+\mu_{b.i}(w)+\mu_{p.i}(w)\]
is calculated with the function `getMort()`.

### Plankton Mortality

The predation mortality rate on plankton is given by a similar expression
as the predation mortality on fish:
\begin{equation}
  \label{eq:mupp}
  \mu_{p}(w_p) = \sum_j \text{pred_rate}_j(w_p).
\end{equation}
This is the only mortality on plankton currently implemented in mizer.
It is calculated with the function `getPlanktonMort()`.


## The MizerParams object and setup functions

The parameters specifying a mizer size-spectrum model are stored in the slots
of an object of class MizerParams. The following table lists the names of the
slots, where they are described in the previous section, and the setup
functions for them.

In this section again we are assuming that the MizerParams object holding
the model parameters is called `params`.

### Logarithmically spaced weight classes
In general the weight classes used by mizer are arbitrary and are
stored in the vector `params@w` for the fish part of the spectrum and in
`params@w_full` for the entire spectrum. The only restriction is that the
weights in these vectors are strictly increasing and that the last
entries of `params@w_full` coincide with the entries of `params@w`.



All currently implemented setup functions use logarithmically spaced
size classes, so that
`w[j]=w[1]*exp(j*dx)` for some `dx`.

### Fixed predator/prey mass ratio
An important simplification occurs when the preference of a predator for
prey $\phi_i(w,w_p) depends on the size of the prey **only** through the 
predator/prey size ratio $w_p/w$. 

The choice of the function is not central. It is currently
hard-coded to the truncated log-normal function

\begin{equation}
  \label{eq:4}
  \phi_i(w,w_p) = \begin{cases}
  \exp \left[ \frac{-(\ln(w/(w_p \beta_i)))^2}{2\sigma_i^2} \right]
  &\text{ if }w/w_p\in\left[0,\beta_i\exp(3\sigma_i)\right]\\
  0&\text{ otherwise,}
  \end{cases}
\end{equation}
where $\beta_i$ is the preferred predator-prey mass ratio and $\sigma_i$ the 
width of the weight selection function.

### Allometric scaling
$c_p(w)$ is the carrying
capacity, which takes the value $\kappa w^{-\lambda} = \kappa w^{-2-q+n}$ by default.

## Analysis functions

## Plotting functions


# Finding your way around the mizer code

## The MizerParams object
An object of class 'MizerParams' holds all the information needed for the
'project()' method to simulate a model. 

## The project methods

## The MizerSim object



## Shiny apps

# Developer guidelines

## Collaborating on Github

## Coding style
[Google's R Style Guide](https://google.github.io/styleguide/Rguide.xml)
[The tidyverse style guide](http://style.tidyverse.org/)

## Always write tests for your code
We use [testthat](http://testthat.r-lib.org/) and
[shinytest](https://rstudio.github.io/shinytest/articles/shinytest.html).

# Technical details

## The numerical scheme

## Fast Fourier Transform

## Tuning to Steady State
